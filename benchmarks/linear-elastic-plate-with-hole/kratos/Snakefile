import json
import os

tool = "kratos"
result_dir = "snakemake_results/" + config["benchmark"] 
configuration_to_parameter_file = config["configuration_to_parameter_file"]
configurations = config["configurations"]

kratos_input_template = f"{tool}/input_template.json"
kratos_material_template = f"{tool}/StructuralMaterials_template.json"

rule mesh_to_mdpa:
    input:
        parameters = lambda wildcards: configuration_to_parameter_file[wildcards.configuration],
        mesh = f"{result_dir}/mesh/mesh_{{configuration}}.msh",
        script = f"{tool}/msh_to_mdpa.py",
    output:
        mdpa = f"{result_dir}/{tool}/mesh_{{configuration}}.mdpa",
    conda:
        "environment_simulation.yml",
    shell:
        """
        python3 {input.script} \
            --input_parameter_file {input.parameters} \
            --input_mesh_file {input.mesh} \
            --output_mdpa_file {output.mdpa}
        """

rule create_kratos_input_and_run_simulation:

    # The process combines the creation of the Kratos input file (json) and the execution of the simulation. Initially, these were two separate processes. 
    # The combination was necessary because the create_kratos_input.py specifies the location of the mesh file and the output location of the simulation results in 
    # the json file. In the case of Nextflow, these locations are related to the process's sub-directory (inside the work directory). Executing the simulation as a 
    # separate process results in a failure to find the mesh file and write the output files unless the paths (in the json file) are explicitly provided as an input 
    # to the process.

    # This is not an issue in the case of Snakemake, as the working directory doesn't automatically change between different rules.

    input:
        parameters = lambda wildcards: configuration_to_parameter_file[wildcards.configuration],
        mdpa = f"{result_dir}/{tool}/mesh_{{configuration}}.mdpa",
        kratos_input_template = kratos_input_template,
        kratos_material_template = kratos_material_template,
        script_create_kratos_input = f"{tool}/create_kratos_input.py",
        script_run_kratos_simulation = f"{tool}/run_kratos_simulation.py",
    output:
        kratos_inputfile = f"{result_dir}/{tool}/ProjectParameters_{{configuration}}.json",
        kratos_materialfile = f"{result_dir}/{tool}/MaterialParameters_{{configuration}}.json",
        result_vtk = f"{result_dir}/{tool}/{{configuration}}/Structure_0_1.vtk",
    conda:
        "environment_simulation.yml",
    shell:
        """
        python3 {input.script_create_kratos_input} \
            --input_parameter_file {input.parameters} \
            --input_mdpa_file {input.mdpa} \
            --input_kratos_input_template {input.kratos_input_template} \
            --input_material_template {input.kratos_material_template} \
            --output_kratos_inputfile {output.kratos_inputfile} \
            --output_kratos_materialfile {output.kratos_materialfile}

        python3 {input.script_run_kratos_simulation} \
            --input_parameter_file {input.parameters} \
            --input_kratos_inputfile {output.kratos_inputfile} \
            --input_kratos_materialfile {output.kratos_materialfile}
        """

rule postprocess_kratos_results:
    input:
        parameters = lambda wildcards: configuration_to_parameter_file[wildcards.configuration],
        result_vtk = f"{result_dir}/{tool}/{{configuration}}/Structure_0_1.vtk",
        script = f"{tool}/postprocess_results.py",
    output:
        zip = f"{result_dir}/{tool}/solution_field_data_{{configuration}}.zip",
        metrics = f"{result_dir}/{tool}/solution_metrics_{{configuration}}.json",
    conda:
        "environment_simulation.yml",
    shell:
        """
        python3 {input.script} \
            --input_parameter_file {input.parameters} \
            --input_result_vtk {input.result_vtk} \
            --output_solution_file_zip {output.zip} \
            --output_metrics_file {output.metrics}
        """

